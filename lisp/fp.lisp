
(let const std/fn/const)
(let floor std/float/floor)
(let ceil std/float/ceil)

(let extreme std/vector/int/extreme)
(let map/tuple (lambda fn xs (std/tuple/map xs fn)))
(let map/fst (lambda fn xs (std/tuple/map/fst xs fn)))
(let map/snd (lambda fn xs (std/tuple/map/snd xs fn)))
(let flat-map (lambda fn xs (std/vector/flat-map xs fn)))
(let map (lambda fn xs (std/vector/map xs fn)))
(let for (lambda fn xs (std/vector/for xs fn)))
(let for/i (lambda fn xs (std/vector/for/i xs fn)))

(let each (lambda xs fn (do (std/vector/for xs fn) xs)))
(let each/i (lambda xs fn (do (std/vector/for/i xs fn) xs)))

(let filter (lambda fn? xs (std/vector/filter xs fn?)))
(let reduce (lambda fn init xs (std/vector/reduce xs fn init)))
(let reduce/until (lambda fn fn? init xs (std/vector/reduce/until xs fn fn? init)))
(let transpose std/vector/3d/rotate)
(let interleave std/vector/2d/interleave)
(let intersperse (lambda xs x (std/vector/intersperse x xs)))
(let every? (lambda fn? xs (std/vector/every? xs fn?)))
(let some? (lambda fn? xs (std/vector/some? xs fn?)))
(let empty? std/vector/empty?)
(let not-empty? std/vector/not-empty?)

(let exclude (lambda fn? xs (std/vector/filter xs (lambda x (not (fn? x))))))
(let select (lambda fn? xs (std/vector/filter xs fn?)))

(let find (lambda fn? xs (std/vector/find-index xs fn?)))
(let partition (lambda n xs (std/vector/partition xs n)))
(let reverse std/vector/reverse)


(let slice (lambda start end xs (std/vector/slice xs start end)))
(let cons std/vector/cons)
(let range std/vector/int/range)
(let range/int std/vector/int/range)
(let range/float std/vector/float/range)
(let square std/int/square)
(let expt (lambda b x (std/int/expt x b)))
(let sqrt std/int/sqrt)
(let expt/int (lambda b x (std/int/expt x b)))
(let sqrt/int std/int/sqrt)
(let expt/float (lambda b x (std/float/expt x b)))
(let sqrt/float std/float/sqrt)
(let odd? std/int/odd?)
(let even? std/int/even?)
(let odd/int? std/int/odd?)
(let even/int? std/int/even?)
(let odd/float? std/float/odd?)
(let even/float? std/float/even?)
(let one? std/int/one?)
(let zero? std/int/zero?)
(let one/int? std/int/one?)
(let zero/int? std/int/zero?)
(let one/float? std/float/one?)
(let zero/float? std/float/zero?)

(let map/until (lambda fn fn? xs (std/vector/map/until xs fn fn?)))
(let map/until/i (lambda fn fn? xs (std/vector/map/until/i xs fn fn?)))
(let reduce/until (lambda fn fn? init xs (std/vector/reduce/until xs fn fn? init)))
(let reduce/until/i (lambda fn fn? init xs (std/vector/reduce/until/i xs fn fn? init)))
(let for/until (lambda fn fn? xs (std/vector/for/until xs fn fn?)))
(let for/until/i (lambda fn fn? xs (std/vector/for/until/i xs fn fn?)))

(let each/until (lambda fn fn? xs (do (std/vector/for/until xs fn fn?) xs)))
(let each/until/i (lambda fn fn? xs (do (std/vector/for/until/i xs fn fn?) xs)))

(let map/i (lambda fn xs (std/vector/map/i xs fn)))
(let reduce/i (lambda fn init xs (std/vector/reduce/i xs fn init)))
(let filter/i (lambda fn? xs (std/vector/filter/i xs fn?)))
(let some/i? (lambda fn? xs (std/vector/some/i? xs fn?)))
(let every/i? (lambda fn? xs (std/vector/every/i? xs fn?)))

(let ones std/vector/int/ones)
(let zeroes std/vector/int/zeroes)
(let ones/int std/vector/int/ones)
(let zeroes/int std/vector/int/zeroes)
(let ones/float std/vector/float/ones)
(let zeroes/float std/vector/float/zeroes)

(let positive? std/int/positive?)
(let negative? std/int/negative?)
(let invert std/int/invert)
(let negative-one? std/int/negative-one?)
(let divisible? (lambda y x (std/int/divisible? x y)))

(let positive/int? std/int/positive?)
(let negative/int? std/int/negative?)
(let invert/int std/int/invert)
(let negative-one/int? std/int/negative-one?)
(let divisible/int? (lambda y x (std/int/divisible? x y)))

(let positive/float? std/float/positive?)
(let negative/float? std/float/negative?)
(let invert/float std/float/invert)
(let negative-one/float? std/float/negative-one?)
(let divisible/float? (lambda y x (std/float/divisible? x y)))

(let upper std/char/upper)
(let lower std/char/lower)
(let match? std/vector/char/equal?)

(let digit? std/char/digit?)
(let fill std/vector/2d/fill)

(let max std/int/max)
(let min std/int/min)
(let max/int std/int/max)
(let min/int std/int/min)
(let max/float std/float/max)
(let min/float std/float/min)

(let maximum std/vector/int/maximum)
(let minimum std/vector/int/minimum)
(let maximum/int std/vector/int/maximum)
(let minimum/int std/vector/int/minimum)
(let maximum/float std/vector/float/maximum)
(let minimum/float std/vector/float/minimum)

(let gt? (lambda a b (and (=? a true) (=? b false))))
(let lt? (lambda a b (and (=? a false) (=? b true))))
(let and? (lambda a b (and (=? a true) (=? b true))))
(let or? (lambda a b (or (=? a true) (=? b true))))
(let not? (lambda x (not x)))

(let abs std/int/abs)
(let abs/int std/int/abs)
(let abs/float std/float/abs)

(let first std/vector/first)
(let last std/vector/last)
(let pair (lambda a b (tuple a b)))
(let product std/vector/int/product)
(let product/int std/vector/int/product)
(let product/float std/vector/float/product)
(let sum std/vector/int/sum)
(let sum/int std/vector/int/sum)
(let sum/float std/vector/float/sum)
(let avg std/int/average)
(let avg/int std/int/average)
(let avg/float std/float/average)
(let mean std/vector/int/mean)
(let median std/vector/int/median)
(let mean/int std/vector/int/mean)
(let mean/float std/vector/float/mean)
(let median/int std/vector/int/median)
(let median/float std/vector/float/median)
(let zip std/vector/tuple/zip)
(let unzip std/vector/tuple/unzip)

(let window std/vector/sliding-window)
(let flat std/vector/flat-one)
(let enumerate std/vector/enumerate)
(let clamp (lambda limit x (std/int/clamp x limit)))
(let clamp-range (lambda start end x (std/int/clamp-range x start end)))

(let clamp/int (lambda limit x (std/int/clamp x limit)))
(let clamp-range/int (lambda start end x (std/int/clamp-range x start end)))
(let clamp/float (lambda limit x (std/float/clamp x limit)))
(let clamp-range/float (lambda start end x (std/float/clamp-range x start end)))

(let at std/vector/at)
(let scan (lambda fn xs (std/vector/adjacent-difference xs fn)))
(let cycle std/vector/cycle)
(let replicate std/vector/replicate)
(let cartesian-product std/vector/cartesian-product)
(let lcm std/int/lcm)
(let gcd std/int/gcd)

(let delta std/int/delta)
(let delta/int std/int/delta)
(let delta/float std/float/delta)

(let map/adjacent (lambda fn xs (std/vector/map/adjacent xs fn)))

(let buckets std/vector/buckets)

(let count/char (lambda x xs (std/vector/char/count xs x)))
(let count/int (lambda x xs (std/vector/int/count xs x)))
(let count/float (lambda x xs (std/vector/float/count xs x)))
(let count/bool (lambda x xs (std/vector/bool/count xs x)))

(let count (lambda fn? xs (std/vector/count-of xs fn?)))

(let points (lambda fn? xs (std/vector/3d/points xs fn?)))

(let unique/int std/vector/int/unique)
(let unique/char std/vector/char/unique)

(let permutation std/vector/permutations)
(let combination/pairs std/vector/tuple/unique-pairs)
(let combination std/vector/combinations)
(let combination/n (lambda n xs (std/vector/combinations/n xs n)))
(let subset std/vector/subset)


(let in-bounds? std/vector/in-bounds?)

(let take/first (lambda n xs (std/vector/take xs n)))
(let drop/first (lambda n xs (std/vector/drop xs n)))

(let take/last (lambda n xs (std/vector/take/last xs n)))
(let drop/last (lambda n xs (std/vector/drop/last xs n)))

(let true/option std/true/option)
(let false/option std/false/option)
(let resolve/option (lambda fn df xs (std/vector/option/resolve xs fn df)))

(let call (lambda fn xs (std/fn/exec xs fn)))

(let copy std/vector/copy)
(let sort (lambda fn xs (std/vector/sort! (std/vector/copy xs) fn)))

(let neighborhood (lambda directions y x fn xs (std/vector/3d/adjacent xs directions y x fn)))
(let neighborhood/moore std/vector/3d/moore-neighborhood)
(let neighborhood/diagonal std/vector/3d/diagonal-neighborhood)
(let neighborhood/kernel std/vector/3d/kernel-neighborhood)
(let neighborhood/von-neumann std/vector/3d/von-neumann-neighborhood)

(let group (lambda fn xs (std/vector/tuple/hash/table/group-by xs fn)))
(let append! (lambda x xs (do (push! xs x) xs)))
(let tail (lambda xs (std/vector/slice xs 1 (length xs))))
(let head (lambda xs (std/vector/slice xs 0 (- (length xs) 1))))

(let fp/mul (lambda b a (* a b)))
(let fp/div (lambda b a (/ a b)))
(let fp/add (lambda b a (+ a b)))
(let fp/sub (lambda b a (- a b)))
(let fp/emod (lambda b a (emod a b)))
(let fp/mod (lambda b a (mod a b)))