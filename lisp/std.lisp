(let char:A 65)
(let char:B 66)
(let char:C 67)
(let char:D 68)
(let char:E 69)
(let char:F 70)
(let char:G 71)
(let char:H 72)
(let char:I 73)
(let char:J 74)
(let char:K 75)
(let char:L 76)
(let char:M 77)
(let char:N 78)
(let char:O 79)
(let char:P 80)
(let char:Q 81)
(let char:R 82)
(let char:S 83)
(let char:T 84)
(let char:U 85)
(let char:V 86)
(let char:W 87)
(let char:X 88)
(let char:Y 89)
(let char:Z 90)
(let char:a 97)
(let char:b 98)
(let char:c 99)
(let char:d 100)
(let char:e 101)
(let char:f 102)
(let char:g 103)
(let char:h 104)
(let char:i 105)
(let char:j 106)
(let char:k 107)
(let char:l 108)
(let char:m 109)
(let char:n 110)
(let char:o 111)
(let char:p 112)
(let char:q 113)
(let char:r 114)
(let char:s 115)
(let char:t 116)
(let char:u 117)
(let char:v 118)
(let char:w 119)
(let char:x 120)
(let char:y 121)
(let char:z 122)
(let char:0 48)
(let char:1 49)
(let char:2 50)
(let char:3 51)
(let char:4 52)
(let char:5 53)
(let char:6 54)
(let char:7 55)
(let char:8 56)
(let char:9 57)
(let char:empty 0)
(let char:double-quote 34)
(let char:new-line 10)
(let char:space 32)
(let char:comma 44)
(let char:dot 46)
(let char:semi-colon 59)
(let char:colon 58)
(let char:dash 45)
(let char:left-brace 40)
(let char:right-brace 41)
(let char:curly-left-brace 123)
(let char:curly-right-brace 125)
(let char:left-bracket 91)
(let char:right-bracket 93)
(let char:pipe 124)
(let char:hash 35)
(let char:question-mark 63)
(let char:exclamation-mark 33)
(let char:minus 45)
(let char:plus 43)
(let char:equal 61)
(let char:asterix 42)
(let char:ampersand 38)
(let char:at 64)
(let char:backtick 96)
(let digit? (lambda ch (and (>= ch char:0) (<= ch char:9))))
(let upper (lambda char (if (and (>= char char:a) (<= char char:z)) (- char char:space) char)))
(let lower (lambda char (if (and (>= char char:A) (<= char char:Z)) (+ char char:space) char)))
(let identity (lambda x x))


(let true (= 1 1))
(let false (= 0 1))
(let nil 0)

(let at (lambda xs i (if (< i 0) (get xs (+ (length xs) i)) (get xs i))))
(let first (lambda xs (get xs 0)))
(let second (lambda xs (get xs 1)))
(let third (lambda xs (get xs 3)))
(let last (lambda xs (get xs (- (length xs) 1))))

(let map (lambda xs cb (loop 0 (length xs) (lambda i (cb (get xs i))))))
(let range (lambda start end (loop start (+ end 1) (lambda i i))))
(let reduce (lambda xs cb init (dotimes 0 (length xs) (lambda a i (cb a (get xs i))) init)))

(let square (lambda x (* x x)))
(let even? (lambda x (= (mod x 2) 0)))
(let odd? (lambda x (not (= (mod x 2) 0))))
(let summation (lambda xs (reduce xs (lambda a b (+ a b)) 0)))
(let product (lambda xs (reduce xs (lambda a b (* a b)) 1)))
(let euclidean-mod (lambda a b (mod (+ (mod a b) b) b)))
(let max (lambda a b (if (> a b) a b)))
(let min (lambda a b (if (< a b) a b)))
(let maximum (lambda xs (reduce xs max (get xs 0))))
(let minimum (lambda xs (reduce xs min (get xs 0))))
(let normalize (lambda value min max (* (- value min) (/ (- max min)))))
(let linear-interpolation (lambda a b n (+ (* (- 1 n) a) (* n b))))
(let gauss-sum (lambda n (/ (* n (+ n 1)) 2)))
(let gauss-sum-sequance (lambda a b (/ (* (+ a b) (+ (- b a) 1)) 2)))
(let clamp (lambda x limit (if (> x limit) limit x)))
(let clamp-range (lambda x start end (cond (> x end) end (< x start) start (*) x)))
(let empty? (lambda xs (= (length xs) 0)))
(let not-empty? (lambda xs (not (= (length xs) 0))))
; (let count-of (lambda xs cb? (length (filter xs cb?))))
; (let count (lambda input item (count-of input (lambda x (= x item)))))
(let in-bounds? (lambda xs index (and (< index (length xs)) (>= index 0))))


; (let match? (lambda a b (and (= (length a) (length b)) (|>
;    a
;    (ziper b)
;    (every? (lambda x (= (get x 0) (get x 1))))))))

; (let ziper (lambda a b (do 
;       (let out [])
;       (iterate a (lambda i (push! out [(get a i)])))
;       (iterate b (lambda i (push! (get out i) (get b i))))
;       out)))

; (let zip (lambda xs (ziper (first xs) (second xs))))
; (let unzip (lambda xs (array (map xs first) (map xs second))))

(let char->digit (lambda ch (- ch char:0)))
(let chars->digits (lambda digits (map digits char->digit)))
(let digit->char (lambda digit (+ digit char:0)))
(let digits->chars (lambda digits (map digits digit->char)))


(let true? (lambda x (= (get x) true)))
(let false? (lambda x (= (get x) false)))
